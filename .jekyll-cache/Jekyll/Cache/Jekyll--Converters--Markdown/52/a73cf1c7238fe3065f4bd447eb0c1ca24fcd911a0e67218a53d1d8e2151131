I"‚><h4 id="1-å‰è¨€">1. å‰è¨€</h4>

<p>â€‹        åœ¨å’Œ iOS ç›¸æœºæ‰“äº¤é“çš„æ—¶å€™ï¼Œæˆ‘ä»¬ç»å¸¸ä¼šé‡åˆ° CVPixelBuffer è¿™ä¸ªç±»å‹ã€‚å®ƒä»£è¡¨äº† iOS æ‘„åƒå¤´æ•è·çš„æ•°æ®æµä¸­çš„ä¸€å¸§ã€‚CV å‰ç¼€è¡¨ç¤ºå®ƒå±äº CoreMedia æ¡†æ¶ã€‚åœ¨æœ‰ä¸€äº›æ—¶å€™ï¼Œæˆ‘ä»¬å¯èƒ½éœ€è¦ç›´æ¥å¯¹æ•°æ®æµè¿›è¡Œå¤„ç†ï¼ŒåŒ…æ‹¬è£å‰ªã€æ—‹è½¬ã€é•œåƒã€ç¼©æ”¾ã€ä»¥åŠè‰²å½©ç©ºé—´è½¬æ¢ã€‚</p>

<p>â€‹        ä¸€ä¸ªå…¸å‹çš„æƒ…å†µï¼Œéœ€è¦æ¯ç§’30å¸§å¤„ç†çš„åœºæ™¯ã€‚æ¯”å¦‚éœ€è¦å®ç°äººè„¸çš„è·Ÿè¸ªå’Œè´´çº¸çš„SDKï¼Œéœ€è¦è®¡ç®—äººè„¸ç‰¹å¾ç‚¹ï¼Œè¿™æ—¶å€™å¯èƒ½éœ€è¦å°†åŸå§‹è¾“å…¥çš„ CVPixelBuffer ä» 1280 * 720çš„å›¾åƒåšé¡ºæ—¶é’ˆæ—‹è½¬ï¼Œæ‹¿åˆ° 720 * 1280 çš„CVPixelBufferã€‚å¯èƒ½åŒæ—¶è¿˜éœ€è¦è£å‰ªäººè„¸å›¾åƒï¼Œè¿˜æœ‰ç¼©æ”¾äººè„¸å›¾åƒç”¨äºæ·±åº¦å­¦ä¹ ç­‰æ“ä½œã€‚åœ¨æœ€åï¼Œå°†å¤„ç†å®Œæˆçš„ CVPixelBuffer é€šè¿‡GPU æ¸²æŸ“åˆ°å±å¹•ã€‚</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CVPixelBuffer--&gt;| è£å‰ª/æ—‹è½¬/ç¼©æ”¾ç­‰æ“ä½œ |OutCVPixelBuffer--&gt;|GPU Render|View
</code></pre></div></div>

<h4 id="2-æ¡†æ¶">2. æ¡†æ¶</h4>

<p>â€‹        å¯¹ CVPixelBuffer åšæ—‹è½¬ã€è£å‰ªã€é•œåƒã€ç¼©æ”¾ã€è‰²å½©ç©ºé—´è½¬æ¢ç­‰ï¼Œæˆ‘ä»¬ä¸»è¦æœ‰ä¸¤ä¸ªå·¥å…·ã€‚ ä¸€ä¸ªæ˜¯åº•å±‚çº§Accelerate ä¸­çš„ <strong>vImage</strong> ã€‚å¦å¤–ä¸€ä¸ªæ˜¯ <strong>Core Image</strong>ã€‚</p>

<p>â€‹         <strong>vImage</strong>  æ˜¯ä¸€ä¸ªé«˜æ€§èƒ½çš„å›¾åƒå¤„ç†æ¡†æ¶ï¼Œå®ƒä¼šå°½é‡åˆ©ç”¨ CPU ä¸Šçš„å‘é‡å¤„ç†å™¨åšè¿ç®—ã€‚å®ƒåŒ…æ‹¬å·ç§¯ã€å‡ ä½•å˜æ¢æ ¼å¼é•¿è‚‰ç­‰ç­‰åŠŸèƒ½ã€‚vImage ç‰¹åˆ«é€‚åˆå¤§å›¾åƒå’Œå®æ—¶è§†é¢‘æµçš„å¤„ç†ã€‚</p>

<p>â€‹        Core Image åˆ™æ˜¯åŸºäº Core Graphicsã€Image I/O ã€Core Video ä¹‹ä¸Šæ›´é«˜çº§çš„å°è£…ã€‚æœ€åº•å±‚æ˜¯ OpenGL/OpenGL ES ï¼ˆé€‰æ‹©GPUæ¸²æŸ“æ—¶ï¼‰ï¼ŒGCDï¼ˆé€‰æ‹©CPUæ¸²æŸ“æ—¶ï¼‰ã€‚</p>

<h4 id="3-vimage-å®ç°">3. vImage å®ç°</h4>

<h5 id="31-vimage-è£å‰ª">3.1 vImage è£å‰ª</h5>

<p>ç¬¬ä¸€æ­¥ï¼Œè·å– CVPixelBufferRef çš„è‰²å½©ç©ºé—´ï¼Œé»˜è®¤ kCVPixelFormatType_32BGRA</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OSType inputPixelFormat = CVPixelBufferGetPixelFormatType(sourcePixelBuffer);
</code></pre></div></div>

<p>ç¬¬äºŒæ­¥ï¼Œé”ä½è¾“å…¥ CVPixelBufferRef</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>if (CVPixelBufferLockBaseAddress(sourcePixelBuffer, kCVPixelBufferLock_ReadOnly) != kCVReturnSuccess) {
    NSLog(@"Could not lock base address");
    return nil;
}
</code></pre></div></div>

<p>ç¬¬ä¸‰æ­¥ï¼Œè·å–CVPixelBufferRef æ•°æ®ï¼ˆé¦–åœ°å€ï¼‰ä»¥åŠæ¯è¡Œæ’åˆ—å­—èŠ‚æ•°å’Œè£å‰ªçš„åç§»ä½ç½®</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>void *sourceData = CVPixelBufferGetBaseAddress(sourcePixelBuffer);
size_t sourceBytesPerRow = CVPixelBufferGetBytesPerRow(sourcePixelBuffer);
size_t offset = CGRectGetMinY(croppingRect) * sourceBytesPerRow + CGRectGetMinX(croppingRect) * 4;

</code></pre></div></div>

<p>ç¬¬å››æ­¥ï¼Œè£å‰ª  CVPixelBufferRef</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vImage_Buffer croppedvImageBuffer = {
    .data = ((char *)sourceData) + offset,
    .height = (vImagePixelCount)CGRectGetHeight(croppingRect),
    .width = (vImagePixelCount)CGRectGetWidth(croppingRect),
    .rowBytes = sourceBytesPerRow
};
</code></pre></div></div>

<p>ç¬¬äº”æ­¥ï¼Œè·å–è£å‰ªåçš„ CVPixelBuffer</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OSType pixelFormat = CVPixelBufferGetPixelFormatType(sourcePixelBuffer);
CVPixelBufferRef outputPixelBuffer = NULL;
CVPixelBufferCreateWithBytes(nil, croppingRect.size.width, croppingRect.size.height, pixelFormat, croppedvImageBuffer.data , croppedvImageBuffer.rowBytes, pixelBufferReleaseCallBack, nil, nil, &amp;outputPixelBuffer);
</code></pre></div></div>

<p>å¦‚æœå†åŠ ä¸Šä¸€äº›åˆ¤ç©ºç­‰ï¼Œå¯ä»¥å¤§è‡´å¾—åˆ°ä¸‹é¢çš„ä»£ç ï¼š</p>

<pre><code class="language-objective-c">CVPixelBufferRef vImageCropPixelBuffer(CVPixelBufferRef sourcePixelBuffer,
                                          CGRect croppingRect)
{
    OSType inputPixelFormat = CVPixelBufferGetPixelFormatType(sourcePixelBuffer);

    if (CVPixelBufferLockBaseAddress(sourcePixelBuffer, kCVPixelBufferLock_ReadOnly) != kCVReturnSuccess) {
        NSLog(@"Could not lock base address");
        return nil;
    }

    void *sourceData = CVPixelBufferGetBaseAddress(sourcePixelBuffer);
    if (sourceData == NULL) {
        NSLog(@"Error: could not get pixel buffer base address");
        CVPixelBufferUnlockBaseAddress(sourcePixelBuffer, kCVPixelBufferLock_ReadOnly);
        return nil;
    }
    
    size_t sourceBytesPerRow = CVPixelBufferGetBytesPerRow(sourcePixelBuffer);
    size_t offset = CGRectGetMinY(croppingRect) * sourceBytesPerRow + CGRectGetMinX(croppingRect) * 4;

    // Crop
    vImage_Buffer croppedvImageBuffer = {
        .data = ((char *)sourceData) + offset,
        .height = (vImagePixelCount)CGRectGetHeight(croppingRect),
        .width = (vImagePixelCount)CGRectGetWidth(croppingRect),
        .rowBytes = sourceBytesPerRow
    };

    /* The ARGB8888, ARGB16U, ARGB16S and ARGBFFFF functions work equally well on
     * other channel orderings of 4-channel images, such as RGBA or BGRA.*/
    CVPixelBufferUnlockBaseAddress(sourcePixelBuffer, kCVPixelBufferLock_ReadOnly);
    
    OSType pixelFormat = CVPixelBufferGetPixelFormatType(sourcePixelBuffer);
    CVPixelBufferRef outputPixelBuffer = NULL;
    CVReturn status = CVPixelBufferCreateWithBytes(nil, croppingRect.size.width, croppingRect.size.height, pixelFormat, croppedvImageBuffer.data , croppedvImageBuffer.rowBytes, pixelBufferReleaseCallBack, nil, nil, &amp;outputPixelBuffer);

    if (status != kCVReturnSuccess) {
        NSLog(@"Error: could not create new pixel buffer");
        free(sourceData);
        return nil;
    }

    return outputPixelBuffer;
}

</code></pre>

<h5 id="32-vimage-ç¼©æ”¾">3.2 vImage ç¼©æ”¾</h5>

<p>å¦‚æœéœ€è¦åœ¨è£å‰ªä¹‹ååŠ ä¸Šç¼©æ”¾æ“ä½œï¼Œéå¸¸å®¹æ˜“ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// scaledSize æ˜¯ CGSize ç±»å‹
size_t scaledBytesPerRow = scaledSize.width * 4;
void *scaledData = malloc(scaledSize.height * scaledBytesPerRow);
if (scaledData == NULL) {
    NSLog(@"Error: out of memory");
    return nil;
}

vImage_Buffer scaledvImageBuffer = {
    .data = scaledData,
    .height = (vImagePixelCount)scaledSize.height,
    .width = (vImagePixelCount)scaledSize.width,
    .rowBytes = scaledBytesPerRow
};
</code></pre></div></div>

<h5 id="33-vimage-æ—‹è½¬">3.3 vImage æ—‹è½¬</h5>

<p>æ—‹è½¬çš„æ ¸å¿ƒä¹Ÿæ˜¯ç±»ä¼¼çš„é€»è¾‘ï¼Œå…ˆå°† CVPixelBuffer è½¬æ¢æˆ vImage_Buffer inbuffï¼Œç„¶åå£°æ˜ outbuffï¼Œç”¨<strong>vImageRotate90_ARGB8888</strong> ï¼ˆä¸»è¦è‰²å½©ç©ºé—´ï¼‰è¿›è¡Œæ—‹è½¬ï¼Œæ ¸å¿ƒä»£ç å¦‚ä¸‹</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>vImage_Buffer inbuff                = {srcBuff, height, width, bytesPerRow};
vImage_Buffer outbuff               = {dstBuff, outHeight, outWidth, bytesPerRowOut};
vImageRotate90_ARGB8888(&amp;inbuff, &amp;outbuff, rotationConstant, bgColor, 0);
</code></pre></div></div>

<h5 id="34-vimage-è‰²å½©ç©ºé—´å˜æ¢">3.4 vImage è‰²å½©ç©ºé—´å˜æ¢</h5>

<p>è‰²å½©ç©ºé—´å˜æ¢éœ€è¦äº†è§£ä¸€ä¸‹è‰²å½©æ’åˆ—çš„æ¦‚å¿µï¼Œæœ¬æ–‡ä¸èµ˜è¿°ã€‚æ­¥éª¤æ˜¯ç”¨å…ˆç”¨ vImage_Buffer è·å–åˆ°é€šé“ï¼Œç„¶åé€šè¿‡vImage ä¸­ <strong>Conversion.h</strong> ä¸­ç›¸åº”çš„ vImageConvert æ–¹æ³•å»ç”Ÿæˆå¯¹åº”çš„ vImage_Bufferï¼Œç„¶åè½¬æˆå¯¹åº”è‰²å½©ç©ºé—´çš„ CVPixelBufferRef ï¼Œä»¥ <strong>YUV</strong> è½¬ <strong>BGRA</strong> ä¸¾ä¾‹ï¼š</p>

<pre><code class="language-objective-c">- (CVPixelBufferRef) YUV2BGRA:(CVPixelBufferRef)imageBuffer
{
    CVPixelBufferLockBaseAddress(imageBuffer, 0);
    
    // å£°æ˜ kCVPixelFormatType_32BGRA CVPixelBufferRef
    int width = (int)CVPixelBufferGetWidthOfPlane(imageBuffer, 0);
    int height = (int)CVPixelBufferGetHeightOfPlane(imageBuffer, 0);
    if (destBuffer == nil) {
        CVPixelBufferCreate(kCFAllocatorDefault, width, height, kCVPixelFormatType_32BGRA, nil, &amp;destBuffer);
    }
    CVPixelBufferLockBaseAddress(destBuffer, 0);
    
    // é€šè¿‡vImage_Buffer è·å–åŸå§‹ CVPixelBufferRef ä¸­çš„ Y é€šé“
    vImage_Buffer srcYp;
    srcYp.height = height;
    srcYp.width = width;
    srcYp.rowBytes =  CVPixelBufferGetBytesPerRowOfPlane(imageBuffer, 0);
    srcYp.data = CVPixelBufferGetBaseAddressOfPlane(imageBuffer, 0);
    
    // é€šè¿‡vImage_Buffer è·å–åŸå§‹ CVPixelBufferRef ä¸­çš„ UV é€šé“
    vImage_Buffer srcCbCr;
    srcCbCr.height = (int)CVPixelBufferGetHeightOfPlane(imageBuffer, 1);
    srcCbCr.width = (int)CVPixelBufferGetWidthOfPlane(imageBuffer, 1);
    srcCbCr.rowBytes =CVPixelBufferGetBytesPerRowOfPlane(imageBuffer, 1);
    srcCbCr.data = CVPixelBufferGetBaseAddressOfPlane(imageBuffer, 1);
    
    // 32BGRA é€šè¿‡vImage_Buffer
    vImage_Buffer dest;
    dest.height = height;
    dest.width = width;
    dest.rowBytes = dest.width*4;
    dest.data = CVPixelBufferGetBaseAddress(destBuffer);
    
    vImage_Error error;
    
    // æ ¸å¿ƒè½¬æ¢æ–¹æ³• vImageConvert_420Yp8_CbCr8ToARGB8888
    //  BGRA - iOS åªæ”¯æŒ BGRA
    uint8_t permuteMap[4] = {3, 2, 1, 0};
    error = vImageConvert_420Yp8_CbCr8ToARGB8888(&amp;srcYp, &amp;srcCbCr, &amp;dest, _conversionInfo, permuteMap, 255, 0);
    CVPixelBufferUnlockBaseAddress(imageBuffer, 0);
    
    if (error != kvImageNoError) {
        CVPixelBufferUnlockBaseAddress(destBuffer,0);
        return nil;
    }
    return destBuffer;
}
</code></pre>

<h4 id="4-core-image-å®ç°">4. Core Image å®ç°</h4>

<p>Core Image å¤„ç†åˆ™éå¸¸ç®€å•ï¼Œæˆ‘ä»¬ä¸éœ€è¦å»å…³å¿ƒ vImage ä¸­bitmapç›¸å…³çš„éƒ¨åˆ†ï¼Œä¸è¿‡éœ€è¦æ³¨æ„çš„ä¸€ç‚¹æ˜¯ [CIContext:render:toCVPixelBuffer]  éœ€è¦iOS 9.3 ä¹‹åçš„ç³»ç»Ÿã€‚</p>

<h5 id="core-image-ä¸­çš„å¤„ç†">Core Image ä¸­çš„å¤„ç†</h5>

<p>ç¬¬ä¸€æ­¥ï¼Œå£°æ˜è¾“å…¥ CVPixelBuffer çš„  CIImage</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CIImage *image = [CIImage imageWithCVImageBuffer:pixelBuffer];
</code></pre></div></div>

<p>ç¬¬äºŒæ­¥ï¼Œå°†CGSize è½¬æˆ Core Image ä¸­çš„åæ ‡ï¼ˆå’ŒUIKit ä¸åŒï¼Œå·¦ä¸‹è§’ä¸ºåŸç‚¹ï¼‰ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>size_t originHeight = CVPixelBufferGetHeight(pixelBuffer);
CGRect realCropRect =  CGRectMake(cropRect.origin.x, originHeight -  cropRect.size.height - cropRect.origin.y , cropRect.size.width , cropRect.size.height);
</code></pre></div></div>

<p>è£å‰ªï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>image = [image imageByCroppingToRect:realCropRect];
</code></pre></div></div>

<p>ç¼©æ”¾ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CGFloat scaleX = scaleSize.width / CGRectGetWidth(image.extent);
CGFloat scaleY = scaleSize.height / CGRectGetHeight(image.extent);
image = [image imageByApplyingTransform:CGAffineTransformMakeScale(scaleX, scaleY)];
</code></pre></div></div>

<p>æ—‹è½¬ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>image = [image imageByApplyingOrientation:orientation]; ä¸­é—´ï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸€æ­¥æ“ä½œï¼š
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>image = [image imageByApplyingTransform:CGAffineTransformMakeTranslation(-image.extent.origin.x, -image.extent.origin.y)];

[CIContext:render:toCVPixelBuffer]
</code></pre></div></div>

<p>ä¸ºäº†ä½¿ç”¨  [CIContext:render:toCVPixelBuffer] ï¼Œæˆ‘ä»¬éœ€è¦è¿›è¡Œä¸€æ­¥</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>image = [image imageByApplyingTransform:CGAffineTransformMakeTranslation(-image.extent.origin.x, -image.extent.origin.y)]; 
</code></pre></div></div>

<p>æœ€åï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CVPixelBufferRef output = NULL;
CVPixelBufferCreate(nil,
                    CGRectGetWidth(image.extent),
                    CGRectGetHeight(image.extent),
                    CVPixelBufferGetPixelFormatType(pixelBuffer),
                    nil,
                    &amp;output);
if (output != NULL) {
    [context render:image toCVPixelBuffer:output]; // æ³¨æ„ iOS 9.3 ä¹‹å
}
</code></pre></div></div>

<h4 id="å¯¹æ¯”">å¯¹æ¯”</h4>

<p>æ—¢ç„¶æ˜¯ä¸åŒçš„æ¡†æ¶è¾¾åˆ°åŒæ ·çš„ç›®çš„ï¼Œé¡ºä¾¿æ¥ä¸€å‘æ€§èƒ½å¯¹æ¯”ï¼ˆæ³¨æ„ï¼Œè¦ç”¨Release æ¨¡å¼æ‰å‡†ç¡®ï¼‰ï¼š</p>

<ul>
  <li>
    <p>ç›¸æœºæ¨¡å¼ï¼š AVCaptureSessionPresetPhoto</p>
  </li>
  <li>
    <p>æµ‹è¯•æœºå‹ï¼š iPhone XR /  iOS 13.3</p>
  </li>
</ul>

<p>éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œè¿™é‡Œå¢åŠ äº†Core Image context ä¸­å„ç§è®¾ç½®ï¼Œè¿™ä¸ªè®¾ç½®å’ŒCore Image åº•å±‚è°ƒåº¦ç›¸å…³ï¼š</p>

<ul>
  <li>æ˜¯å¦å¼ºåˆ¶ä½¿ç”¨GPU</li>
  <li>æ˜¯å¦å§‹ç»ˆåœ¨GPUä¸­å¤„ç†ï¼ˆæ²¡æœ‰GPU å’Œ CPU è¿›è¡Œå†…å­˜äº¤æ¢ï¼Œæ•ˆç‡ä¼šæ›´é«˜ï¼‰</li>
</ul>

<p>å¯¹æ¯”ç»“æœå¦‚ä¸‹ï¼š</p>

<table>
  <thead>
    <tr>
      <th>Type</th>
      <th>CPU Usage ï¼ˆ%ï¼‰</th>
      <th>Memery usage ï¼ˆMBï¼‰</th>
      <th style="text-align: center">Time usageï¼ˆmsï¼‰</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Core Image / kEAGLRenderingAPIOpenGLES2</td>
      <td>19</td>
      <td>60</td>
      <td style="text-align: center">10</td>
    </tr>
    <tr>
      <td>Core Image contextWithOptions</td>
      <td>15</td>
      <td>52.9</td>
      <td style="text-align: center">9</td>
    </tr>
    <tr>
      <td>Core Image CPU</td>
      <td>11</td>
      <td>40</td>
      <td style="text-align: center">7</td>
    </tr>
    <tr>
      <td>vImage</td>
      <td>45</td>
      <td>51</td>
      <td style="text-align: center">11</td>
    </tr>
  </tbody>
</table>

<p>CIContext çš„å£°æ˜æ–¹å¼åˆ†åˆ«æ˜¯ï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>eaglctx = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];   
context = [CIContext contextWithEAGLContext:eaglctx]; // è®°å¾—å¤ç”¨ CIContext
</code></pre></div></div>

<p>ä»¥åŠï¼š</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// context = [CIContext contextWithOptions: nil];  
context = [CIContext contextWithOptions: [NSDictionary dictionaryWithObject:[NSNumber numberWithBool:YES] forKey:kCIContextUseSoftwareRenderer]];
</code></pre></div></div>

<p>å¯è§ Core Image æ¯”èµ· vImage è¿˜æ˜¯å¿«äº†ä¸€äº›ï¼ŒAPI ä¹Ÿæ›´ç®€å•ï¼Œæ‰€ä»¥å¦‚æœç‰ˆæœ¬å…è®¸ï¼ˆé«˜ç‰ˆæœ¬APIï¼‰ï¼Œæ›´æ¨èä½¿ç”¨Core Image è¿›è¡ŒCVPixelBufferçš„å„ç§å¤„ç†ã€‚</p>

<p>ä¸è¿‡ï¼ŒCore Image è¦è€ƒè™‘å¦å¤–ä¸€äº›å› ç´ ï¼Œæ¯”å¦‚GPUå’ŒCPUä¸Šçš„å›¾ç‰‡åˆ†è¾¨ç‡é™åˆ¶ï¼Œå†…å­˜äº¤æ¢ç­‰ç­‰ï¼Œéœ€è¦è¯»è€…è‡ªè¡Œå»é˜…è¯»æ–‡æ¡£å’Œæ¢ç´¢ã€‚</p>

<p>ä¾‹å¦‚ï¼šCPU ä¸Šå¯å¤„ç†çš„æœ€é«˜åˆ†è¾¨ç‡æ˜¯ 16384 * 16384ï¼ŒGPUä¸Šæœ€å¤§çš„åˆ†è¾¨ç‡æ˜¯ 4096 * 4096</p>

<h4 id="å‚è€ƒ">å‚è€ƒ</h4>

<ol>
  <li><a href="https://developer.apple.com/documentation/accelerate/vimage">vImage</a></li>
  <li><a href="https://colin1994.github.io/2016/10/21/Core-Image-OverView/#3-_CPU_/_GPU">Core Image ä½ éœ€è¦äº†è§£çš„é‚£äº›äº‹~</a></li>
  <li><a href="https://objccn.io/issue-21-6/">Core Image ä»‹ç»</a></li>
  <li><a href="https://github.com/DikeyKing/DKCamera/blob/master/DKCamera/DKImageConverter/DKImageConverter.mm/">å‚è€ƒä»£ç </a></li>
  <li><a href="https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/CoreImaging/ci_performance/ci_performance.html#//apple_ref/doc/uid/TP30001185-CH10-SW1">Core Image Programming Guide</a></li>
</ol>
:ET